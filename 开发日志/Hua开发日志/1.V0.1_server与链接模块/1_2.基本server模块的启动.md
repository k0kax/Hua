### 1.初始化server
在server.go中，添加如下代码，初始化一个Server模块的对象s,并对其进行初始化服务，添加一些属性，最后将s返回
#查漏补缺 [[1.&的应用]]

```go
func NewServer(name string) hiface.IServer {  
  
	s := &Server{  
	Name: name,  
	IPversion: "TCP4",  
	IP: "0.0.0.0",  
	Port: 8999,  
	}  
	return s  
}
```
### 2.创建一个测试客户端
新建一个测试文件夹/mydemo/Hua_V0.1,新建文件Server.go
此处要修改为main包，进行数据调用
```go
package main  
  
import "Hua/hnet"  
  
/*  
基于Hua开发的 服务器端应用程序  
*/  
	func main() {  
	//1.新建server句柄，使用Hua的api  
	s := hnet.NewServer("[Hua V0.1]")  
	  
	//2.启动server  
	s.Serve()  
}
```

### 3.server.go的启动运行关闭方法

既然服务器运行，那么一定启动，那么就需要在Serve()方法中，调用Start()方法
```go
Serve(){
	Start()
}
```
修改Start（）方法，此处涉及到socket连接的内容和相关Go方法的应用，有点复杂
```go
//0.添加日志记录
func (s *Server) Start() {  
//0.日志记录  
		fmt.Println("[Start] Server Listenner at IP:%s,port:%d is starting!!!", s.IP, s.Port)  
		go func() {  
		//1.获取一个TCP的Addr句柄  
				addr, err := net.ResolveTCPAddr(s.IPversion, fmt.Sprintf("%s:%d", s.IP, s.Port))  
				if err != nil {  
					fmt.Println("resolve tcp addr error", err)  
				}  
				  
				//2.监听服务器的地址 获取监听  
				listernner, err := net.ListenTCP(s.IPversion, addr)  
				if err != nil {  
						fmt.Println("Listern", s.IPversion, "err", err)  
						return  
				}  
				fmt.Println("Start Hua Server succ name:", s.Name, "succ,Listerning....")  
				  
				//3.阻塞的等待客户端连接，处理客户端业务（读写）  
				for {  
				//如果有客户连接进来，阻塞会返回  
						conn, err := listernner.AcceptTCP() //套接字句柄 conn是连接  
						if err != nil {  
						fmt.Println("Accept err", err)  
						continue  
				}  
				  
				//客户端已经建立连接，做一些业务，此处做一个最大512字节回显业务  
				go func() {  
						for {  
							buf := make([]byte, 512)  
							cnt, err := conn.Read(buf) //cnt 是 Read 方法的返回值，表示成功读取的字节数。  
								if err != nil {  
										fmt.Println("recv buf err:", err)  
										continue  
								}  
							  
							//回显功能  
								if _, err := conn.Write(buf[:cnt]); err != nil {  
										fmt.Println("write back buf err")  
										continue  
								}  
							}  
				}()  
			}  
		}()  
}

```

总代码如下